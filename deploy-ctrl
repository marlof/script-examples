#!/bin/bash
#-------------------------------------------------------------------------------
#
#                            DEPLOYMENT FRAMEWORK
#
#-------------------------------------------------------------------------------
#
# COMPONENT     bin/wpdeploy
#
# USAGE         wpdeploy <tag> <option> <argument>...
#
# DESCRIPTION   Main script in the deployment framework.  Takes a tag name and
#               options/arguments required by that tag.  Checks the tag is known
#               and that all options and arguments required are specified.
#
#               Sources the main wpenvs file and the wpenvs file in the space
#               in which the tag lives.
#
#               Ensures all functions required exist, then runs them.
#
#               See etc/wpdeploy.config for tag definitions.
#
# EXAMPLES      wpdeploy DEPLOY -r 1.1 -e ST1
#
#-------------------------------------------------------------------------------
#
# REVISION HISTORY
#
# Date       Author            JIRA      Summary
# ----       ------            ----      -------
# 20140515   Marc Loftus       n/a       Created
#-------------------------------------------------------------------------------
set -u

# DEBUG LIBRARY FUNCTIONS SETTINGS
# ================================
typeset PROGNAME=`basename $0`
O_PROGNAME=${PROGNAME}

#typeset _BASEDIR=$(dirname $(dirname $(dirname $(dirname ${BASH_SOURCE}))))

#-------------------------------------------------------------------------------
# Get our base directory, i.e. the directory holding the "space" dir
#-------------------------------------------------------------------------------
if [[ $(echo ${BASH_SOURCE} | cut -c1) != "/" ]] ; then
   # We have a relative, not an absolute path

   # Work out if we have a "./" or a directory name first
   if [[ $(echo ${BASH_SOURCE} | cut -c1-2) = "./" ]] ; then
      _RELATIVE_PATH=$(echo ${BASH_SOURCE} | cut -c3-)
   else
      _RELATIVE_PATH=${BASH_SOURCE}
   fi

   # Work out the full path of the command
   _FULL_PATH=$(pwd)/${_RELATIVE_PATH}
else
   _FULL_PATH=${BASH_SOURCE}
fi

# We can now work out the base directory from _FULL_PATH as we know wpdeploy is
# held in space/common/bin
_BASEDIR=$(dirname $(dirname $(dirname $(dirname ${_FULL_PATH}))))


#-------------------------------------------------------------------------------
# Source the common envs file
#-------------------------------------------------------------------------------
. ${_BASEDIR}/space/common/etc/wpenvs
# Common envs include DEPHOME BINDIR ETCDIR VARDIR LOGDIR SPACEDIR FUNCDIR TMPDIR JOBIDFILE RELMGR_<envs>

#-------------------------------------------------------------------------------
# Source all common functions
#-------------------------------------------------------------------------------
for _FUNCTION in $(ls ${SPACEDIR}/common/functions) ; do
   bash ${SPACEDIR}/common/functions/${_FUNCTION} > /dev/null 2>&1
   if (( $? == 0 )) ; then
      source ${SPACEDIR}/common/functions/${_FUNCTION}
   fi
done


# Cannot create the LOG_FILE until the envs and jobid are set
LOG_FILE=${LOGDIR}/$(date ${DATEFORMAT})-${PROGNAME}-$$.log # LOG File

# Global variables that require setup before the script runs correctly
# ====================================================================
typeset LOGGING=file # Log level: file | none | interactive (Used with WPMessage)
typeset DEBUG=off    # Debug Level: on | off | full (Used with WPCheckRC)
#typeset DEPHOME=$(dirname ${RUNDIR})
typeset VERSION=0.0
typeset DATEFORMAT="+%y%m%d-%H%M%S"
typeset STARTTIME="$(date +%s)"
typeset NONINTERACTIVE=""
#typeset DEPLOYMENTTEAM="dldeploymentteam@worldpay.com"
#typeset SEPERATOR="-------------------------------------------------------------------------------------------------------------------"
typeset SEPERATOR="-----------------------------------------------------------------------------------------------"
typeset NEW_ARGS=""
typeset FUNCTIONNAME=""
typeset LIVE="FALSE"
typeset LISTTAGS="FALSE"
declare -a _ARG_ARRAY


# ARGUMENTS LIST FIRST CHECK ARGUMENTS TO THE FRAMEWORK
# =====================================================
PROGARGUMENTS=""
if [ $# -ne 0 ] ; then
  while [ $# -gt 0 ] ; do
    _ARG="$1"
    case ${_ARG} in
      -l ) LISTTAGS="TRUE" ;;
      -h ) Help ; exit 0;;
      -d ) DEBUG=full ; set +u ;;
      -n ) NONINTERACTIVE=1 ;;
      -wpenvs ) shift; WPENVS=${_ARG} ;;
      -v ) echo "VERSION[$PROGNAME] $VERSION" ; exit 0 ;;
      -f ) FORCE=1 ;;
      *  ) FUNCTIONNAME=${_ARG} ; shift ; break ;;
    esac
    PROGARGUMENTS="${PROGARGUMENTS} ${_ARG}"
    shift
  done
fi

# Now check arguments to the FUNCTIONNAME
# =======================================
ARGUMENTS=""
if [ $# -ne 0 ] ; then
  while [ $# -gt 0 ] ; do
    _ARG="$1"
    ARGUMENTS="${ARGUMENTS} ${_ARG}"
_ARG_ARRAY[${#_ARG_ARRAY[*]}]="${_ARG}"
    shift
  done
fi




Help()
{
  # Help should always be available in any script
  # =============================================

  Usage
  echo " "
  echo "${PROGNAME} [-l] | FUNCTION_TAG [options]"
  echo "    -h     Help"
  echo "    -l     Lists the available tags"
  echo "    -v     Version"
  echo " "
  echo "    Examples:"
  echo " "
}


Usage()
{
  echo "${PROGNAME} [-l] FUNCTION_TAG [options] | -h | -v "
}


CheckSetUp()
{
  REFER_MODULE=$(pop "${MODULE}")
  MODULE=$(push "$MODULE" "CheckSetUp")
  SCENE="Entering CheckSetUp"

  WPCheckRC 0 "Entering CheckSetUp"

  # If we dont have a DEPHOME then we cant continue
  #[[ -z "${DEPHOME}" ]] && WPError "The DEPHOME variable has not been set in the ${ENVFILES}"

  # Check function name was passed
  [[ -z "${FUNCTIONNAME}" ]] && Usage && WPError "No FUNCTION TAG provided"


  # Make the LOG directory if it doesnt exist
  [[ ! -d ${LOGDIR} ]] && mkdir -p -m 775 ${LOGDIR}


  WPCheckRC 0 " Leaving CheckSetUp"
  MODULE=$(cdr "$MODULE")
}

ShowSetup()
{
  REFER_MODULE=$(pop "${MODULE}")
  MODULE=$(push "$MODULE" "ShowSetup")
  SCENE="Entering ShowSetup"

  WPCheckRC 0 "Entering ShowSetup"

  check_log
  WPMessage ${SEPERATOR}
  WPMessage "Program   :       ${PROGNAME} ${PROGARGUMENTS} ${FUNCTIONNAME} ${ARGUMENTS} "
  WPMessage "Log file  :       ${LOG_FILE}"
  WPMessage ${SEPERATOR}
  WPMessage "TIME      :       $(date)"
  WPMessage "SERVER    :       ${HOSTNAME}"
  WPMessage "USER      :       ${DEPLOYER}"
  WPMessage "JOBID     :       ${_JOBID}"
  WPMessage "VERSION   :       ${VERSION}"
  WPMessage ${SEPERATOR}
  WPMessage "BASEDIR   :       ${BASEDIR}"
  WPMessage ${SEPERATOR}



  WPMessage "Deployment team email: ${DEPLOYMENTTEAM}"
  WPCheckRC 0 " Leaving ShowSetup"
  MODULE=$(cdr "$MODULE")

}

ListTags()
{
  # The user has only requested a LIST of available tags or requested detailed information about one tag
  if [[ -z ${FUNCTIONNAME} ]] ; then
    grep -v "^#" ${CONFIGFILE} | grep ";" | cut -d";" -f1,4-
  else
    grep -v "^#" ${CONFIGFILE} | grep ${FUNCTIONNAME}
  fi
  exit 0
}

SourceProperties()
{
  # Loops through the space directories looking for common and space related environments files
  # ===========================================================================================
  ENVSFILES=$(find -L ${SPACEDIR} -name "${ENVSFILENAME}" | grep /${_L_SPACE}/ )


  REFER_MODULE=$(pop "${MODULE}")
  MODULE=$(push "$MODULE" "SourceProperties")
  SCENE="Entering SourceProperties"
  WPCheckRC 0 "Entering SourceProperties"

  #[ "$NONINTERACTIVE" ] || clear

  WPCheckRC 0 "SPACEDIR: $SPACEDIR"
  WPCheckRC 0 "ENVS: ${ENVSFILES}"

  # The common wpenvs file should also find some service wpenvs as well
  if [ ! "${ENVSFILES}" ] ;  then
    WPWarning "There are no env files found using command: find -L ${SPACEDIR} -name ${ENVSFILENAME}"
    #WPError "Cannot find ENVSFILENAME <${ENVSFILENAME}> files in ENV_DIR <${SPACEDIR}>"
  else
    #WPMessage ${SEPERATOR}
    WPMessage "Loading space ENV files."
    #Found ${WPENVSFILES}"

    # Search for all wpenvs files in the space directories
    for _EACH_FILE in $(echo ${ENVSFILES} | grep /${_L_SPACE}/) ; do
      typeset _STATUS="${greenf}Done${reset}  "
      typeset _FORMATTED_ENVFILE=$(printf "%-20s" "${_EACH_FILE}" )

      # Source the found environment files into a subshell first to help protect the framework script
      bash ${_EACH_FILE} > /dev/null 2>&1
      if [ $? = 0 ] ; then
        # If the file sourced ok we can bring it into this script
        . ${_EACH_FILE}
      else
        _STATUS="${redf}Failed${reset}"
      fi
      WPMessage "\t${_STATUS}\t${_FORMATTED_ENVFILE}"
    done
  fi

  WPCheckRC 0 " Leaving SourceProperties"
  MODULE=$(cdr "$MODULE")
}

GetJobID()
{
  # DESCRIPTION :  creates a job id for tracking runs and increments by one if required

  REFER_MODULE=$(pop "${MODULE}")
  MODULE=$(push "$MODULE" "GetJobID")
  SCENE="Entering GetJobID"

  WPCheckRC 0 "Entering GetJobID"

  # Check JOBIDFIEL variable is set
  if [ -z "${JOBIDFILE}" ] ; then
        WPError "JOBIDFILE Variable has not been set ... cannot continue"
  fi

  # Get the JOBID number if the file might contain it
  if [ -e "${JOBIDFILE}" ] && [ -r "${JOBIDFILE}" ]  ; then
    _JOBID=$(cat ${JOBIDFILE})
  else
    _JOBID=0
  fi

  touch "${JOBIDFILE}" > /dev/null 2>&1
  chmod 755 "${JOBIDFILE}" > /dev/null 2>&1

  # Set the new number
  if [ -w "${JOBIDFILE}" ] ; then
    (( _JOBID+=1 ))
        echo ${_JOBID} > ${JOBIDFILE}
  else
    WPError "Cannot increment the JOBIDFILE <${JOBIDFILE}>"
  fi


  export _JOBID

  WPCheckRC 0 " Leaving GetJobID"
  MODULE=$(cdr "$MODULE")
  SCENE="Leaving GetJobID"
}


ValidateFunctionTAG()
{
  # DESCRIPTION :  Checks the passed function tag name against the CONFIGFILE (wpdeploy.config) for a line
  #                beginning with the function name . It then makes sure those functions are available and
  #                sources then into the framework
  #
  #                CONFIGFILE=$ETCDIR/wpdeploy.config
  #
  #                DEPLOYPSC ; PSC ; req:r:RELEASE req:e:ENVIRONMENT opt:f opt:v opt:type:TYPE ; PSC_DeployPreSteps ; PULLPSC ; PUSHPSC ; DEPLOYPSC

  REFER_MODULE=$(pop "${MODULE}")
  MODULE=$(push "$MODULE" "ValidateFunctionTAG")
  SCENE="Entering ValidateFunctionTAG"

  WPCheckRC 0 "Entering ValidateFunctionTAG"

  WPMessage ${SEPERATOR}
  WPMessage "TAG       :       ${FUNCTIONNAME}"
  WPMessage "ARGUMENTS :       ${ARGUMENTS}"
  WPMessage ${SEPERATOR}
  # Check FUNCTION exists in the config file
  [[ -z "${CONFIGFILE}" ]] &&   WPError "Variable CONFIGFILE not set. Check WPENVS files"
  [[ ! -r "${CONFIGFILE}" ]] && WPError "Function CONFIGFILE (${CONFIGFILE}) not found"

  #typeset local FUNC_LIST=$(grep "^${FUNCTIONNAME}:"  ${CONFIGFILE})
  typeset local _STRING _ARG _MATCH NEXT FOUND

  FUNC_LIST=$(grep -w "^${FUNCTIONNAME}"  ${CONFIGFILE})

  if [ "${FUNC_LIST}" ] ; then

    # If the FUNCTION name exists in the CONFIGFILE
    # Get SPACE name and find arguments and functions
    SPACE=$(echo ${FUNC_LIST} | cut -d";" -f 2)
    _L_SPACE=$(echo ${SPACE} | tr '[A-Z]' '[a-z]')
    SPACE=$(echo ${_L_SPACE} | tr '[a-z]' '[A-Z]')           # This it to get rid of anyleading and trailing spaces
    WPMessage "SPACE: <${SPACE}>"

    # Check we're on the right host type.
    _HOST_TYPE=$(echo ${FUNC_LIST} | cut -d";" -f3 | awk '{print $1}')
    [[ ${_HOST_TYPE} = $(${WPGET} -p) ]] || WPError "Tag ${FUNCTIONNAME} should only be executed on ${_HOST_TYPE} hosts.  This is a $(${WPGET} -p) host."


    WPMessage "Passed parameter list"
    TEST_ARGS="$(echo ${FUNC_LIST} | cut -d";" -f4 ) "
    WPCheckRC 0 "Arg check : $TEST_ARGS"

#DEBUG=on

    # Loop through the list or arguments set in the config file
    for _FUNCTION_ARG in ${TEST_ARGS} ; do
      WPCheckRC 0 ${_FUNCTION_ARG}
      _STRING=$(echo " ${_FUNCTION_ARG}" | awk -F":" '{print $2}')
      _ARG=$(echo " ${_FUNCTION_ARG}" | awk -F":" '{print $2}')
      _MATCH=$(echo " ${_FUNCTION_ARG}" | awk -F":" '{print $3}')
      NEXT=0

      # Check for required and optional arguments
      if [[  "$(echo ${_FUNCTION_ARG} | grep "^req:")" ]] ; then

        # echo "Required arg"
        # If 4 Arguments are passed we are expecting a value to be passed also
        if [[ $(echo ${_FUNCTION_ARG} | awk -F":" '{print NF}') -eq 4 ]] ; then
          WPCheckRC 0 "required"

          # Loop through the user supplied arguments to see if they are in the required list
          FOUND=0
          for _EACH_ARG in "${_ARG_ARRAY[@]-}"
          do
            if [[ $NEXT -eq 1 ]] ; then
              eval ${_STRING}="\"${_EACH_ARG}\""
              WPMessage "\t${_STRING} : ${!_STRING}"
              FOUND=1
            fi
            if [[ "${_EACH_ARG}" = "-${_MATCH}"  ]] ; then
              NEXT=1
            else
              NEXT=0
            fi

          done



#          for _EACH_ARG in $ARGUMENTS ; do
#            if [[ $NEXT -eq 1 ]] ; then
#              eval ${_STRING}=${_EACH_ARG}
#              WPMessage "\t${_STRING} : ${!_STRING}"
#              FOUND=1
#            fi
#            if [[ "${_EACH_ARG}" = "-${_MATCH}"  ]] ; then
#              NEXT=1
#            else
#               NEXT=0
#            fi
#          done

          # Check if the required arg from config was on the command line
          if [[ "$FOUND" -eq "0" ]] ; then
            WPWarning "Required argument ${_FUNCTION_ARG} was not passed on the argument list (${ARGUMENTS})"
          fi

        else
          WPCheckRC 0  "Required flag -$(echo $_FUNCTION_ARG | cut -d: -f3)"
        fi

      else

        WPCheckRC 0 "Checking for optional -$(echo $_FUNCTION_ARG | cut -d: -f3) "
        if [[ $(echo ${_FUNCTION_ARG} | awk -F":" '{print NF}') -eq 4 ]] ; then
          WPCheckRC 0 "this argument requires a parameter if passed"
          # Loop through the user supplied arguments to see if they are in the optional list
          FOUND=0
          for _EACH_ARG in "${_ARG_ARRAY[@]-}"
          do
            if [[ $NEXT -eq 1 ]] ; then
              eval ${_STRING}="\"${_EACH_ARG}\""
              WPMessage "\t${_STRING} : ${!_STRING}"
              FOUND=1
            fi
            if [[ "${_EACH_ARG}" = "-${_MATCH}"  ]] ; then
              NEXT=1
            else
              NEXT=0
            fi

          done
#          for _EACH_ARG in $ARGUMENTS ; do
#            if [[ $NEXT -eq 1 ]] ; then
#              eval ${_STRING}=${_EACH_ARG}
#              WPMessage "\t${_STRING} : ${!_STRING}"
#              FOUND=1
#            fi
#            if [[ "${_EACH_ARG}" = "-${_MATCH}"  ]] ; then
#              NEXT=1
#            else
#              NEXT=0
#            fi
#          done

          if [[ "$FOUND" -eq "0" ]] ; then
            WPCheckRC 0 "Optional argument ${_FUNCTION_ARG} was not passed on the argument list (${ARGUMENTS})"
          fi

        else

          # The framework has been passed an optional flag which requires setting if set in config
          WPCheckRC 0 "Optional argument flag -$(echo $_FUNCTION_ARG | cut -d: -f3) was passed - setting"
          for _EACH_ARG in $ARGUMENTS ; do
            if [[ $NEXT -eq 1 ]] ; then
              eval ${_STRING}="TRUE"
              WPMessage "\t${_STRING} :  ${!_STRING}"
              FOUND=1
            fi
            if [[ "${_EACH_ARG}" = "-${_MATCH}"  ]] ; then
              NEXT=1
            else
               NEXT=0
            fi
          done

        fi

      fi
    done
  else
    WPError "Cannot find a suitable function definition (${FUNCTIONNAME}) in CONFIGFILE (${CONFIGFILE})"
  fi

  [[ ${WARNINGCOUNT} != 0 ]] && WPError "There were too many warnings to continue at this point"
  WPMessage ${SEPERATOR}

  WPCheckRC 0 " Leaving ValidateFunctionTAG"
  MODULE=$(cdr "$MODULE")
}

Process_Functions()
{
  # DESCRIPTION :  The function will loop through the list of function mentioned in the wpdeploy.config file
  #                and will check if they are readable, then source them and run the function.
  #

  REFER_MODULE=$(pop "${MODULE}")
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"

  WPCheckRC 0 "Entering ${FUNCNAME}"

#DEBUG=on
  #WPMessage "Function list"
  for _FUNCTION_CALL in $(echo ${FUNC_LIST} | cut -d";" -f5- | sed 's/;/ /g' ) ; do
    SPACE_FUNC_DIR=${SPACEDIR}/${_L_SPACE}/functions/
    COMMON_FUNC_DIR=${SPACEDIR}/common/functions/
    SPACE_BIN_DIR=${SPACEDIR}/${_L_SPACE}/bin/
    FUNC=$(echo ${_FUNCTION_CALL} | cut -d";" -f4- | sed 's/;/ /g' )
    WPMessage ${SEPERATOR}
    #WPMessage "${SPACE_FUNC_DIR}${FUNC}"
set +u
    SUPPORTING_TEAM="Deploymentteam@worldpay.com"

    # Check tp see if the named function exists in either the COMMON area or SPACE area
    if [[ -r ${SPACE_FUNC_DIR}${FUNC} ]] ; then
      . ${SPACE_FUNC_DIR}${FUNC}
      WPCheckRC $? "There was an error sourcing the deployment function ${SPACE_FUNC_DIR}${FUNC}"
    elif [[ -r  ${COMMON_FUNC_DIR}${FUNC} ]] ; then
      . ${COMMON_FUNC_DIR}${FUNC}
      WPCheckRC $? "There was an error sourcing the deployment function ${COMMON_FUNC_DIR}${FUNC}"
    else
      WPError "The function ${FUNC} could not be accessed in either ${SPACE_FUNC_DIR} or ${COMMON_FUNC_DIR}. Check directory permissions."
    fi

    CMD="${FUNC}"
    WPMessage "Running: ${SPACE_FUNC_DIR}${FUNC}"
    PROGNAME=${FUNC}

    # Rather then creating a LOGGING PIPE  we can switch the LOGGING type to function while we run external
    # which still allows us to capture return codes from functions
    # example if function1 fails, the command returns success     function1 | tee -a <file>    the tee parts succeeds
    # LOGGING=function allows stdout and stderr to be captured without duplicating the screen output as well
    LOGGING=function
 #   [[ "${LIVE}" == "TRUE" ]] && ECHO="" || ECHO="echo"
    # Trail of EM-474 - fix to tee issue using BASH pipestatus variable
    #${CMD} > >(tee -a ${LOG_FILE})  2> >(tee -a ${LOG_FILE} >&2)
     ${CMD} | tee -a ${LOG_FILE}
     _RC=${PIPESTATUS[0]}
    WPCheckRC ${_RC} "There was an error running the deployment function ${FUNC}"
    LOGGING=file
    PROGNAME=${O_PROGNAME}

  done

  WPCheckRC 0 "Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}

# 19 yy
function_template()
{
  # AUTHOR : <name>
  # DATE CREATED: <date>
  # DESCRIPTION :  <it does this>
  #

  REFER_MODULE=$(pop "${MODULE}")
  MODULE=$(push "$MODULE" "${FUNCNAME}")
  SCENE="Entering ${FUNCNAME}"

  WPCheckRC 0 "Entering ${FUNCNAME}"

  # COMMANDS GO HERE

  WPCheckRC 0 " Leaving ${FUNCNAME}"
  MODULE=$(cdr "$MODULE")
}


##########################################################################
view_change_env()
{
  set | more
  echo " "
  echo "Enter new Variable <or leave blank> and press <RETURN>"
  echo " "
  read ans
  echo "Setting.."
  eval $ans
  sleep 1
}
##########################################################################
check_log()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
#
# Add these parameters to your script before you use the debug library
#    PARAMETER=VALUE
#    PROGNAME=`basename $0`
#    LOG_FILE=/tmp/smecontrol.log # LOG File
#    LOGGING=file # Log level: full | none | interactive
#    DEBUG=off # Used with WPCheckRC: on | off | full

case $LOGGING in
  file|full)
    if [ "$LOG_FILE" ] ; then
      if [ ! -f $LOG_FILE ] ; then
        echo >$LOG_FILE "[${PROGNAME}] log file created on `date`"
        if [ $? -ne 0 ] ; then
          echo >&2 "$(date ${DATEFORMAT}) WARNING[${PROGNAME}] cannot create a new log file (${LOG_FILE})"
          LOGGING=interactive
          LOG_FILE=/dev/null
        fi
      else
        if [ ! -w $LOG_FILE ] ; then
          echo >&2 "$(date ${DATEFORMAT}) WARNING[${PROGNAME}] cannot write to the log file (${LOG_FILE})"
          LOGGING=interactive
          LOG_FILE=/dev/null
        fi
      fi
    else
      echo >&2 "$(date ${DATEFORMAT}) WARNING[${PROGNAME}] no log file defined"
      LOGGING=interactive
      LOG_FILE=/dev/null
    fi
    ;;
    none|interactive|off)
      LOG_FILE=/dev/null
    ;;
    *)
      echo >&2 "$(date ${DATEFORMAT}) WARNING[${PROGNAME}] \$LOGGING set to an illegal value (${LOGGING})"
      LOGGING=interactive
      LOG_FILE=/dev/null
  esac
# LIBRARY FUNCTION
# DO NOT MODIFY
}
##########################################################################
check_file()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
#
# argument 1 = File to be checked
#
if [ `ls $1` ] ; then
  WPCheckRC 0 "Found $1"
else
  WPMessage "check_file($1) DID NOT FIND A FILE"
  exit
fi
}
##########################################################################
push()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
#
# argument 1 = Stack list
# argument 2 = Item to add
# return     = new stack
#
echo "$1 $2"
}
##########################################################################
pop()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
#
# argument 1 = Stack list
# return     = new stack
#
echo $1 | awk '{print $NF}'
}
##########################################################################
cdr()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
#
# argument 1 = Stack list
# return     = new stack
#
echo $1 | awk '{for ( i = 1; i < NF; i++) print $i }'
}
##########################################################################
log_trap()
{
# LIBRARY FUNCTION
# DO NOT MODIFY
  WPWarning "$1"
  WPStatus
  WPError "ABORTED"
  echo " "
  exit 1
}
trap "log_trap \"TERMINATED: User probably logged out\"" 1
trap "log_trap \"TERMINATED: User probably ctrl-c\"" 2
trap "log_trap \"TERMINATED: Illegal Instruction\"" 4
trap "log_trap \"TERMINATED: Probably via kill\"" 15
#trap "log_trap \"\n\nTERMINATED: ERR\"" ERR




InitialiseANSI                                                          # Set up screen colours

#MAIN

MODULE="main"

[[ "${LISTTAGS}" = "TRUE" ]] && ListTags

CheckSetUp
GetJobID                                                                # Get a unique JOB ID for tracking

# Cannot create the LOG_FILE until the envs and jobid are set
LOG_FILE=${LOGDIR}/$(date ${DATEFORMAT})-${PROGNAME}-${_JOBID}-${FUNCTIONNAME}.log # LOG File

#SourceProperties                                                       # Search for wpenvs files in all spaces and source them
ShowSetup                                                               # Display the argument list

ValidateFunctionTAG
SourceProperties                                                        # Search for wpenvs files in all spaces and source them
Process_Functions

typeset ENDTIME="$(date +%s)"
(( TIMETAKEN= ENDTIME-STARTTIME ))
WPMessage ${SEPERATOR}
WPMessage "SUCCESS: Call to ${FUNCTIONNAME} Completed successfully taking ${TIMETAKEN} seconds"
WPMessage ${SEPERATOR}
exit

# Your code goes here:
# e.g.:
function_template
# Example below:


WPMessage "Creating deployment pack $RELEASE"
sleep 3
ENVIRONMENT=BA1
WPMessage "Sending deployment pack to target box $(${WPGET} psc.*${ENVIRONMENT}.*CONSOLE)"
sleep 4
WPMessage "Running commands on remote box"

WPMessage "I am running the close command close ${ARGUMENTS}"
# ADD CLOSE FUNCTION NAME HERE
WPCheckRC 0 "Then you get this message"
sleep 3
echo "Closed the broker"

WPMessage "I am running the stop command"
# ADD CLOSE FUNCTION NAME HERE
WPCheckRC 0 "Then you get this message"
sleep 3
echo "Completed"





exit
